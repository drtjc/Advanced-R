---
title: "Functionals"
output:
  html_document:
    number_sections: yes
    theme: sandstone
    toc: yes
    toc_depth: 3
    toc_float: yes
---

```{r, include=FALSE}
knitr::opts_chunk$set(tidy=TRUE, fig.align='center')
```

```{r, echo=FALSE, include=FALSE}
library(lobstr)
library(pryr)
library(knitr)
library(kableExtra)
library(magrittr)
library(dplyr)
library(tidyverse)
library(rlang)
```

R has what’s known as first class functions. You can do anything with functions that you can do with vectors: you can assign them to variables, store them in lists, pass them as arguments to other functions, create them inside functions, and even return them as the result of a function. A higher-order function is a function that takes a function as an input or returns a function as output. This part of the book is broken down by the three types of higher-order functions:

* **Functionals**, functions are the input. Functionals are by far and away the most immediately useful application of FP ideas, and you’ll use them all the time in data analyses.

* **Function factories**, functions as output. You can almost always avoid function factories in favour of a different technique, but they are occassionally useful.

* **Function operators**, functions as input and output. These are like adverbs, because they typically modify the operation of a function.

# Functionals
## Introduction
A *functional* is a function that takes a function as an input and returns a vector as output. Here’s a simple functional: it calls the function provided as input with 1000 random uniform numbers.

```{r}
randomise <- function(f) f(runif(1e3))
randomise(mean)
randomise(mean)
randomise(sum)
```

The three most frequently used are `lapply()`, `apply()`, and `tapply()`. All three take a function as input (among other things) and return a vector as output.

## `lapply()`
The simplest functional is `lapply()`, which you may already be familiar with. `lapply()` takes a function, applies it to each element in a list, and returns the results in the form of a list. `lapply()` is written in C for performance, but we can create a simple R implementation that does the same thing:

```{r, eval=FALSE}
lapply2 <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}
```

## Looping patterns
It’s useful to remember that there are three basic ways to loop over a vector:

1. loop over the elements: `for (x in xs)`
2. loop over the numeric indices: `for (i in seq_along(xs))`
3. loop over the names: `for (nm in names(xs))`

The first form is usually not a good choice for a for loop because it leads to inefficient ways of saving output. With this form it’s very natural to save the output by extending a data structure, like in this example:

```{r, eval=FALSE}
xs <- runif(1e3)
res <- c()
for (x in xs) {
  # This is slow!
  res <- c(res, sqrt(x))
}
```

This is slow because each time you extend the vector, R has to copy all of the existing elements. Instead, it’s much better to create the space you’ll need for the output and then fill it in. This is easiest with the second form:

```{r, eval=FALSE}
res <- numeric(length(xs))
for (i in seq_along(xs)) {
  res[i] <- sqrt(xs[i])
}
```

Just as there are three basic ways to use a for loop, there are three basic ways to use `lapply()`:

1. `lapply(xs, function(x) {})`
2. `lapply(seq_along(xs), function(i) {})`
3. `lapply(names(xs), function(nm) {})`

Typically you’d use the first form because `lapply()` takes care of saving the output for you. However, if you need to know the position or name of the element you’re working with, you should use the second or third form. Both give you an element’s position (`i`, `nm`) and value (`xs[[i]]`, `xs[[nm]]`).

### Exercises
1. Why are the following two invocations of `lapply()` equivalent?

    ```{r, eval=FALSE}
    trims <- c(0, 0.1, 0.2, 0.5)
    x <- rcauchy(100)
    
    lapply(trims, function(trim) mean(x, trim = trim))
    lapply(trims, mean, x = x)
    ```
**A**: `x = x` is passed to `mean()`, and so `trims` is positionally matched to the `trim` argument of `mean()`.

2. The function below scales a vector so it falls in the range [0, 1]. How would you apply it to every column of a data frame? How would you apply it to every numeric column in a data frame?

    ```{r}
    scale01 <- function(x) {
      rng <- range(x, na.rm = TRUE)
      (x - rng[1]) / (rng[2] - rng[1])
    }
    ```
**A**: 
    ```{r}
    lapply(mtcars, scale01) %>% data.frame() %>% head %>% print(digits = 2)
    
    mt2 <- mtcars %>% rownames_to_column()
    lapply(mt2, function (x) if(is.numeric(x)) scale01(x) else x) %>% data.frame() %>% head %>% print(digits = 2)
    ```

3. Use both for loops and `lapply()` to fit linear models to the `mtcars` using the formulas stored in this list:

    ```{r}
    formulas <- list(
      mpg ~ disp,
      mpg ~ I(1 / disp),
      mpg ~ disp + wt,
      mpg ~ I(1 / disp) + wt
    )
    ```
**A**: 
    ```{r}
    lapply(formulas, lm, mtcars)
    
    res <- vector("list", length(formulas))
    for (i in seq_along(formulas)) {
      res[[i]] <- lm(formulas[[i]], mtcars)
    }
    res
    ```

4. Fit the model `mpg ~ disp` to each of the bootstrap replicates of `mtcars` in the list below by using a `for` loop and `lapply()`. Can you do it without an anonymous function?

    ```{r}
    bootstraps <- lapply(1:3, function(i) {
      rows <- sample(1:nrow(mtcars), rep = TRUE)
      mtcars[rows, ]
    })
    ```
**A**: 
    ```{r}
    lapply(bootstraps, function(x) lm(mpg ~ disp, x))
    lapply(bootstraps, lm, formula = mpg ~ disp)
    
    res <- vector("list", length(bootstraps))
    for (i in seq_along(bootstraps)) {
      res[[i]] <- lm(mpg ~ disp, bootstraps[[i]])
    }
    res    
    ```

5. For each model in the previous two exercises, extract R^2^ using the function below.

    ```{r}
    rsq <- function(mod) summary(mod)$r.squared
    
    mod1 <- lapply(formulas, lm, mtcars)
    mod2 <- lapply(bootstraps, lm, formula = mpg ~ disp)
    lapply(mod1, rsq)
    lapply(mod2, rsq)
    ```

## For loop functionals: friends of `lapply()`
### Vector output: `sapply()` and `vapply()`
`sapply()` and `vapply()` are very similar to `lapply()` except they simplify their output to produce an atomic vector. While `sapply()` guesses, `vapply()` takes an additional argument specifying the output type. `sapply()` is great for interactive use because it saves typing, but if you use it inside your functions you’ll get weird errors if you supply the wrong type of input. `vapply()` is more verbose, but gives more informative error messages and never fails silently. It is better suited for use inside other functions.

```
lapply(X, FUN, ...)
sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)
vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)
```

The following example illustrates these differences. When given a data frame, `sapply()` and `vapply()` return the same results. When given an empty list, `sapply()` returns another empty list instead of the more correct zero-length logical vector.

```{r}
sapply(mtcars, is.numeric)
vapply(mtcars, is.numeric, logical(1))
sapply(list(), is.numeric)
vapply(list(), is.numeric, logical(1))
```

If the function returns results of different types or lengths, `sapply()` will silently return a list, while `vapply()` will throw an error. 

```{r, error=TRUE}
df <- data.frame(x = 1:10, y = letters[1:10])
sapply(df, class)
vapply(df, class, character(1))

df2 <- data.frame(x = 1:10, y = Sys.time() + 1:10)
sapply(df2, class)
vapply(df2, class, character(1))
```

Simplification in `sapply()` is only attempted if `X` has length greater than zero and if the return values from all elements of `X` are all of the same (positive) length. If the common length is one the result is a vector, and if greater than one is a matrix with a column corresponding to each element of `X`.

Simplification is always done in `vapply()`. This function checks that all values of `FUN` are compatible with the `FUN.VALUE`, in that they must have the same length and type.

```{r}
sapply(list(1:2, 3:4), sqrt)
vapply(list(1:2, 3:4), sqrt, numeric(2))
```

`USE.NAMES` - logical; if `TRUE` and if `X` is character, use `X` as `names` for the result unless it had names already. 

```{r}
randomise <- function(f) match.fun(f)(runif(1e3))
sapply(c("mean", "sum"), randomise)
vapply(c("mean", "sum"), randomise, numeric(1))
```

Note, `sapply(*, simplify = FALSE, USE.NAMES = FALSE)` is equivalent to `lapply(*)`.

`sapply()` is a thin wrapper around `lapply()` that transforms a list into a vector in the final step. `vapply()` is an implementation of `lapply()` that assigns results to a vector (or matrix) of appropriate type instead of as a list. The following code shows a pure R implementation of the essence of `sapply()` and `vapply()` (the real functions have better error handling and preserve names, among other things).

```{r, eval=FALSE}
sapply2 <- function(x, f, ...) {
  res <- lapply2(x, f, ...)
  simplify2array(res)
}

vapply2 <- function(x, f, f.value, ...) {
  out <- matrix(rep(f.value, length(x)), nrow = length(f.value))
  for (i in seq_along(x)) {
    res <- f(x[[i]], ...)
    stopifnot(
      length(res) == length(f.value),
      typeof(res) == typeof(f.value)
    )
    out[ ,i] <- res
  }
  out
}
```

Some more complicated examples are:

``` {r}
lapply(list(1:2, 3:4), function(x) outer(x, x)) # list of 2 matrices
sapply(list(1:2, 3:4), function(x) outer(x, x), simplify = FALSE) # list of 2 matrices

(z <- sapply(list(1:2, 3:4), function(x) outer(x, x), simplify = TRUE)) # matrix
dim(z)
is.matrix(z)
is.array(z)

(z <- sapply(list(1:2, 3:4), function(x) outer(x, x), simplify = "array")) # 3d array
# NOTE sapply calls simplify2array() with higher = (simplify == "array"))
dim(z)
is.matrix(z)
is.array(z)

vapply(list(1:2, 3:4), function(x) outer(x, x), outer(1:2, 1:2)) #3d array

fv <- matrix(data = NA_real_, nrow = 2, ncol = 2, dimnames = list(c("u", "v"), c("x", "y")))
vapply(list(a = 1:2, b = 3:4), function(x) outer(x, x), fv) #named 3d array
```

### Replicate
`replicate()` is a wrapper for the common use of sapply for repeated evaluation of an expression (which will usually involve random number generation).

```{r}
replicate

set.seed(456)
replicate(5, mean(runif(2)))
set.seed(456)
sapply(integer(5), function(x) mean(runif(2)))
set.seed(NULL)
```

Be careful about using replicate with additional parameters:

```{r}
foo <- function(x = 1, y = 2) c(x, y)

bar <- function(n, ...) replicate(n, foo(...))
bar(3, 4, 5)
# does not work: Because integer 3 = (0,0,0), and 0 is passed to foo each time  

# This works
bar <- function(n, x, y) replicate(n, foo(x = x, y = y))
bar(3, 4, 5)
```

### Multiple inputs
With `lapply()`, only one argument to the function varies; the others are fixed. This makes it poorly suited for some problems. For example, how would you find a weighted mean when you have two lists, one of observations and the other of weights?

```{r}
# Generate some sample data
xs <- replicate(2, runif(3), simplify = FALSE) 
xs
ws <- replicate(2, rpois(3, 5) + 1, simplify = FALSE)

# simplify = FALSE to stop output being matrix
```

It’s easy to use `lapply()` to compute the unweighted means:

```{r}
unlist(lapply(xs, mean))
```

But how could we supply the weights to `weighted.mean()`? `lapply(x, means, w)` won’t work because the additional arguments to `lapply()` are passed to every call. We could change looping forms:

```{r}
unlist(lapply(seq_along(xs), function(i) {
  weighted.mean(xs[[i]], ws[[i]])
}))
```

This works, but it’s a little clumsy. A cleaner alternative is to use `Map()`, a variant of `lapply()`, where all arguments can vary. This lets us write:

```{r}
unlist(Map(weighted.mean, xs, ws))
```

If some of the arguments should be fixed and constant, use an anonymous function:

```{r}
xs[[2]][[1]] <- NA
xs
Map(function(x, w) weighted.mean(x, w, na.rm = TRUE), xs, ws)
```

`Map()` is a simple wrapper to `mapply()`:

```{r}
Map
```

I prefer `Map()` because:

* It’s equivalent to `mapply` with `simplify = FALSE`, which is almost always what you want.

* Instead of using an anonymous function to provide constant inputs, mapply has the MoreArgs argument that takes a list of extra arguments that will be supplied, as is, to each call. This breaks R’s usual lazy evaluation semantics, and is inconsistent with other functions.

```{r}
mapply(weighted.mean, xs, ws, MoreArgs = list(na.rm = TRUE))
```

### Exercises
TO DO

## Vector fuctionals
Another way of thinking about functionals is as a set of general tools for altering, subsetting, and collapsing vectors. Every functional programming language has three tools for this: `Map()`, `Reduce()`, and `Filter()`. We’ve seen `Map()` already, and the following sections describe `Reduce()`, a powerful tool for extending two-argument functions, and `Filter()`, a member of an important class of functionals that work with predicates, functions that return a single `TRUE` or `FALSE`.

### `Reduce()`
`Reduce()` reduces a vector, `x`, to a single value by recursively calling a function, `f`, two arguments at a time. It combines the first two elements with `f`, then combines the result of that call with the third element, and so on. Calling `Reduce(f, 1:3)` is equivalent to `f(f(1, 2), 3)`. `Reduce` is also known as fold, because it folds together adjacent elements in the list.

The following two examples show what `Reduce` does with an infix and prefix function:

```{r}
Reduce(`+`, 1:3) # -> ((1 + 2) + 3)
Reduce(sum, 1:3) # -> sum(sum(1, 2), 3)
```

The essence of `Reduce()` can be described by a simple for loop:

```{r, eval=FALSE}
Reduce2 <- function(f, x) {
  out <- x[[1]]
  for(i in seq(2, length(x))) {
    out <- f(out, x[[i]])
  }
  out
}
```

The real `Reduce()` is more complicated because it includes arguments to control whether the values are reduced from the left or from the right (`right`), an optional initial value (`init`), and an option to output intermediate results (`accumulate`).

`educe()` is an elegant way of extending a function that works with two inputs into a function that can deal with any number of inputs. It’s useful for implementing many types of recursive operations, like merges and intersections. Imagine you have a list of numeric vectors, and you want to find the values that occur in every element:

```{r}
l <- replicate(5, sample(1:10, 15, replace = T), simplify = FALSE)
str(l)
```

You could do that by intersecting each element in turn:

```{r}
intersect(intersect(intersect(intersect(l[[1]], l[[2]]), l[[3]]), l[[4]]), l[[5]])
```

That’s hard to read. With `Reduce()`, the equivalent is:

```{r}
Reduce(intersect, l)
Reduce(intersect, l, accumulate = TRUE)
```

A more sophisticated example:

```{r}
Funcall <- function(f, ...) f(...)
## n-fold iterate of a function, functional style:
Iterate <- function(f, n = 1) function(y) Reduce(Funcall, rep.int(list(f), n), init = y, right = TRUE)
## Continued fraction approximation to the golden ratio:
Iterate(function(x) 1 + 1 / x, 30)(3)

# what's going on
Iterate(function(x) 1 + 1 / x, 2)(3)

f <- function(x) 1 + 1 / x
rep.int(list(f),2)

r <- Funcall(function (x) 1+1/x, 3)
Funcall(function (x) 1+1/x, r)
```





apply
rapply
tapply

eapply

lengths
aggregate

mclappy()

Reduce, Filter, Find, Negtate, Position

nested loops
assignment


