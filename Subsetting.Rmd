---
title: "Subsetting"
output:
  html_document:
    number_sections: yes
    theme: sandstone
    toc: yes
    toc_depth: 3
    toc_float: yes
---

```{r, include=FALSE}
knitr::opts_chunk$set(tidy=TRUE, results='hold', fig.align='center')
```

```{r, echo=FALSE, include=FALSE}
library(lobstr)
library(pryr)
library(knitr)
library(kableExtra)
library(magrittr)
library(dplyr)
```

# Subsetting
## Atomic vectors
Let’s explore the different types of subsetting with a simple vector, `x`.

```
x <- c(2.1, 4.2, 3.3, 5.4)
```

Note that the number after the decimal point gives the original position in the vector. There are six things that you can use to subset a vector:

* **Positive integers** return elements at the specified positions.
    ```{r, results='markup'}
    x <- c(2.1, 4.2, 3.3, 5.4)
    x[c(3, 1)]
    x[order(x)]
    x[c(1, 1)] # Duplicated indices yield duplicated values
    x[c(2.1, 2.9)] # Real numbers are silently truncated to integers
    ```

* **Negative integers** omit elements at the specified positions. You can’t mix positive and negative integers in a single subset.
    ```{r, results='markup', error=TRUE}
    x[-c(3, 1)]
    x[c(-1, 2)]
    ```

* **Logical vectors** select elements where the corresponding logical value is `TRUE`.  
    ```{r, results='markup', error=TRUE}
    x[c(TRUE, TRUE, FALSE, FALSE)]
    x[x > 3]
    ```
If the logical vector is shorter than the vector being subsetted, it will be *recycled* to be the same length.
    ```{r}
    x[c(TRUE, FALSE)]
    # Equivalent to
    x[c(TRUE, FALSE, TRUE, FALSE)]
    ```
A missing value in the index always yields a missing value in the output.
    ```{r}
    x[c(TRUE, TRUE, NA, FALSE)]
    ```

* **Nothing** returns the original vector. This is not useful for vectors but is very useful for matrices, data frames, and arrays. It can also be useful in conjunction with assignment.
    ```{r}
    x[]
    ```

* *Character vectors* (if the vector is named) to return elements with matching names.
    ```{r, results='markup'}
    (y <- setNames(x, letters[1:4]))
    y[c("d", "c", "a")]

    # Like integer indices, you can repeat indices
    y[c("a", "a", "a")]

    # When subsetting with [ names are always matched exactly
    z <- c(abc = 1, def = 2)
    z[c("a", "d")]
    ```








