---
title: "Subsetting"
output:
  html_document:
    number_sections: yes
    theme: sandstone
    toc: yes
    toc_depth: 3
    toc_float: yes
---

```{r, include=FALSE}
knitr::opts_chunk$set(tidy=TRUE, results='hold', fig.align='center')
```

```{r, echo=FALSE, include=FALSE}
library(lobstr)
library(pryr)
library(knitr)
library(kableExtra)
library(magrittr)
library(dplyr)
```

# Subsetting
## Atomic vectors
Let’s explore the different types of subsetting with a simple vector, `x`.

```
x <- c(2.1, 4.2, 3.3, 5.4)
```

Note that the number after the decimal point gives the original position in the vector. There are six things that you can use to subset a vector:

* **Positive integers** return elements at the specified positions.
    ```{r, results='markup'}
    x <- c(2.1, 4.2, 3.3, 5.4)
    x[c(3, 1)]
    x[order(x)]
    x[c(1, 1)] # Duplicated indices yield duplicated values
    x[c(2.1, 2.9)] # Real numbers are silently truncated to integers
    ```

* **Negative integers** omit elements at the specified positions. You can’t mix positive and negative integers in a single subset.
    ```{r, results='markup', error=TRUE}
    x[-c(3, 1)]
    x[c(-1, 2)]
    ```

* **Logical vectors** select elements where the corresponding logical value is `TRUE`.  
    ```{r, results='markup', error=TRUE}
    x[c(TRUE, TRUE, FALSE, FALSE)]
    x[x > 3]
    ```
If the logical vector is shorter than the vector being subsetted, it will be *recycled* to be the same length.
    ```{r}
    x[c(TRUE, FALSE)]
    # Equivalent to
    x[c(TRUE, FALSE, TRUE, FALSE)]
    ```
A missing value in the index always yields a missing value in the output.
    ```{r}
    x[c(TRUE, TRUE, NA, FALSE)]
    ```

* **Nothing** returns the original vector. This is not useful for vectors but is very useful for matrices, data frames, and arrays. It can also be useful in conjunction with assignment.
    ```{r}
    x[]
    ```

* *Character vectors* (if the vector is named) to return elements with matching names.
    ```{r, results='markup'}
    (y <- setNames(x, letters[1:4]))
    y[c("d", "c", "a")]

    # Like integer indices, you can repeat indices
    y[c("a", "a", "a")]

    # When subsetting with [ names are always matched exactly
    z <- c(abc = 1, def = 2)
    z[c("a", "d")]
    ```

## Lists
Subsetting a list works in the same way as subsetting an atomic vector. Using [ will always return a list; `[[` and `$`, as described below, let you pull out the components of the list.

```{r, results='markup'}
l <- list(1, 2)
str(l)
str(l[1])
```

## Matrices and arrays
You can subset higher-dimensional structures in three ways:

* With multiple vectors.
* With a single vector.
* With a matrix.

The most common way of subsetting matrices (2d) and arrays (>2d) is a simple generalisation of 1d subsetting: you supply a 1d index for each dimension, separated by a comma. Blank subsetting is now useful because it lets you keep all rows or all columns.

```{r, results='markup'}
a <- matrix(1:9, nrow = 3)
colnames(a) <- c("A", "B", "C")
a
a[1:2, ]
a[c(TRUE, FALSE, TRUE), c("B", "A")]
```

By default, `[` will simplify the results to the lowest possible dimensionality. See simplifying vs. preserving to learn how to avoid this.

```{r}
str(a)
class(a)
class(a[1:2, ])
class(a[1, 1])
class(a[1, 1, drop = FALSE])
dim(a[1, 1, drop = FALSE])
```

Because matrices and arrays are implemented as vectors with special attributes, you can subset them with a single vector. In that case, they will behave like a vector. Arrays in R are stored in column-major order:

```{r, results='markup'}
(vals <- outer(1:5, 1:5, FUN = "paste", sep = ","))
vals[5]
vals[c(4, 15)]
```

You can also subset higher-dimensional data structures with an integer matrix (or, if named, a character matrix). Each row in the matrix specifies the location of one value, where each column corresponds to a dimension in the array being subsetted. This means that you use a 2 column matrix to subset a matrix, a 3 column matrix to subset a 3d array, and so on. The result is a vector of values:

```{r}
select <- matrix(ncol = 2, byrow = TRUE, c(
  1, 1,
  3, 1,
  2, 4
))
vals[select]
```

## Data frames
Data frames possess the characteristics of both lists and matrices: if you subset with a single vector, they behave like lists; if you subset with two vectors, they behave like matrices.




