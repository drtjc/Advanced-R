---
title: "Expressions"
output:
  html_document:
    number_sections: yes
    theme: sandstone
    toc: yes
    toc_depth: 3
    toc_float: yes
---

```{r, include=FALSE}
knitr::opts_chunk$set(tidy=TRUE, fig.align='center')
```

```{r, echo=FALSE, include=FALSE}
library(lobstr)
library(pryr)
library(knitr)
library(kableExtra)
library(magrittr)
library(dplyr)
library(tidyverse)
library(rlang)
library(memoise)
library(purrr)
```

# Expressions
It would be nice if we could capture the intent of the code, without executing the code. In other words, how can we separate our description of the action from performing it? One way is to use `rlang::expr()`:

```{r}
z <- expr(y <- x * 10)
z
typeof(z)
class(z)
str(z)

u <- quote(y <- x * 10)
u
typeof(u)
class(u)
str(u)
```

`expr()` returns a quoted expression: the R code that captures our intent.

## Abstract syntax trees
Quoted expressions are also called abstract syntax trees (AST).  To make that more obvious we’re going to introduce some graphical conventions, illustrated with the very simple call `f(x, "y", 1)`.

```{r, out.width="200px", echo=FALSE}
knitr::include_graphics("Images/simple.png")
```

* Function **calls** define the hierarchy of the tree. Calls are shown with an orange square. The first child (`f`) is the function that gets called; the second and subsequent children (`x`, `"y"`, and `1`) are the arguments.

* The leaves of the tree are either **symbols**, like `f` and `x`, or **constants** like `1` or `"y"`. Symbols have a purple border and rounded corners. Constants, which are atomic vectors of length one, have black borders and square corners. Strings are always surrounded in quotes to emphasise their difference from symbols.

```{r}
lobstr::ast(f(x, "y", 1))
```

`ast()` supports “unquoting” with `!!` (pronounced bang-bang). We’ll talk about unquoting in detail in the next chapter; for now note that it’s useful if you’ve already used `expr()` to capture the expression.

```{r}
x <- expr(f(x, "y", 1))

# not useful!
lobstr::ast(x)
#> x

# what we want
lobstr::ast(!!x)
```

### Infix vs. prefix calls
In R, any infix call can be converted to a prefix call if you escape the function name with backticks. That means that these two lines of code are equivalent:

```{r, eval=FALSE}
y <- x * 10
`<-`(y, `*`(x, 10))
```

```{r}
lobstr::ast(y <- x * 10)
lobstr::ast(`<-`(y, `*`(x, 10)))
```

### Special forms
R has a small number of other syntactical constructs that don’t look like either prefix or infix function calls. These are called special forms and include `function`, the control flow operators (`if`, `for`, `while`, `repeat`), and parentheses (`{`, `(`, `[[`, and `[`). These can also be written in prefix form, and hence appear in the same way in the AST:

```{r}
lobstr::ast(function(x, y) {
  if (x > y) {
    x
  } else {
    y
  }
})
```

### Function factories
Another small detail we need to consider are calls like `f()()`. The first component of the call is usually a symbol:

```{r}
lobstr::ast(f(a, 1))
lobstr::ast(f()(a, 1))
lobstr::ast(f(b, 2)(a, 1))
```

### Argument names
So far the examples have only used unnamed arguments. Named arguments don’t change the parsing rules, but just add some additional metadata:

```{r}
lobstr::ast(mean(x = mtcars$cyl, na.rm = TRUE))
```

## R's grammar
The process by which a computer language takes a sequence of tokens (like `x`, +, `y`) and constructs a tree is called **parsing**, and it is governed by a set of rules known as a **grammar**.

### Operator precedence
Infix functions introduce ambiguity in a way that prefix functions do not. The parser has to resolve two sources of ambiguity when parsing infix operators. First, what does `1 + 2 * 3` yield? Programming langauges use conventions called **operator precedence** to resolve this ambiguity.

```{r}
lobstr::ast(1 + 2 * 3)
```

Predicting the precedence of arithmetic operations is usually easy because it’s drilled into you in school and is consistent across the vast majority of programming languages. Predicting the precedence of other operators is harder. There’s one particularly surprising case in R: `!` has a much lower precedence (i.e. it binds less tightly) than you might expect. This allows you to write useful operations like:

```{r}
lobstr::ast(!x %in% y)
```

### Associativity
Ano`ther source of ambiguity is introduced by repeated usage of the same infix function. For example, is `1 + 2 + 3` equivalent to `(1 + 2) + 3 or to `1 + (2 + 3)`? This normally doesn’t matter because `x + (y + z) == (x + y) + z`, i.e. addition is associative, but is needed because some S3 classes define `+` in a non-associative way.

In R, most operators are left-associative, i.e. the operations on the left are evaluated first:
```{r}
lobstr::ast(1 + 2 + 3)
```

There are two exceptions: exponentiation and assignment.

```{r}
lobstr::ast(2 ^ 3 ^ 4)
lobstr::ast(x <- y <- z)
```

### Exercises
1. R uses parentheses in two slightly different ways as illustrated by these two calls:
    ```{r, eval=FALSE}
    f((1))
    `(`(1 + 1)
    ```
Compare and contrast the two uses by referencing the AST.
**A**: `(` can represent a primitive function but also be a part of R’s general prefix function syntax.
    ```{r}
    lobstr::ast(f((1)))
    lobstr::ast(`(`(1 + 1))
    
    lobstr::ast(f(1)) # same as lobstr::ast(f((1)))
    lobstr::ast(1 + 1)
    lobstr::ast((1 + 1)) # bracket appears as not part of function syntax
    ```

2. `=` can also be used in two ways. Construct a simple example that shows both uses.  
**a**: `=` can be used for assignment or two match to named arguments.
    ```{r}
    lobstr::ast(x = 1) # just the leaf 1
    lobstr::ast(x = (a = 1))
    lobstr::ast((a = 1)) # same as one above
    ```

3. What does `!1 + !1` return? Why?  
    ```{r}
    !1 + !1
    !(1 + (!1)) # same as above
    lobstr::ast(!1 + !1)
    (!1) + (!1) # = 0 as is FALSE + FALSE
    ```

4. Why does `x1 <- x2 <- x3 <- 0` work? There are two reasons.  
**A**: `<-` is right associative. Assignment returns the value being assigned.
    ```{r}
    lobstr::ast(x1 <- x2 <- x3 <- 0)
    lobstr::ast(0 -> x3 -> x2 -> x3)
    ```

5. Compare the ASTs `x + y %+% z` and `x ^ y %+% z`. What does that tell you about the precedence of custom infix functions?  
**A**: Custom infix functions have a precedence between addition and exponentiation
    ```{r}
    lobstr::ast(x + y %+% z)
    lobstr::ast(x ^ y %+% z)
    ```

## Data structures
In this section you’ll learn about the data structures that appear in the AST:

* Constants and symbols form the leaves of the tree.
* Calls form the branches of the tree.
* Pairlists are a largely historical data structure that are now only used for function arguments.

### Naming conventions
Before we continue, a word of caution about the naming conventions used in this book. Because base R evolved organically, it does not have a set of names that are used consistently throughout all functions. Instead, we’ve adopted our own set of conventions, and used them consistently throughout the book and in rlang. You will need to remember some translations when reading base R documentation.

The biggest difference is the use of the term “expression”. We use expression to refer to the set containing **constants**, **symbols**, **calls**, and **pairlists**. In base R, “expression” is a special type that is basically equivalent to a list of what we call expressions. To avoid confusion we’ll call these expression objects, and we’ll discuss them in expression objects. Base R does not have an equivalent term for our “expression”. The closest is “language object”, which includes symbols and calls, but not constants or pairlists.

But note that `typeof()` and `str()` use “language” not for language objects, but instead to mean calls. Base R uses symbol and name interchangeably; we prefer symbol because “name” has other common meanings (e.g. the name of a variable).

### Constants
Constants occurred in the leaves of the AST. They are the simplest data structure found in the AST because they are atomic vectors of length 1. Constants are “self-quoting” in the sense that the expression used to represent a constant is the constant itself:

```{r}
identical(expr("x"), "x")
identical(expr(TRUE), TRUE)
identical(expr(1), 1)
identical(expr(2), 2)
```

### Symbols
Symbols represent variable names. They are basically a single string stored in a special way. You can convert back and forth between symbols and the strings that represent them with `sym()` and `as_string()`:

```{r}
"x"
sym("x")
class(sym("x"))
typeof(sym("x"))
as_string(sym("x"))

class(quote(x))
typeof(quote(x))
identical(sym("x"), quote(x))
```

There’s one special symbol that needs a little extra discussion: the empty symbol which is used to represent missing arguments (not missing values!). You can make it with `missing_arg()` (or `expr()`):

```{r}
missing_arg()
typeof(missing_arg())
as_string(missing_arg())

quote(...)
typeof(quote(...))

is_missing(missing_arg())

```


