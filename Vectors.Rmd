---
title: "Vectors"
output:
  html_document:
    number_sections: yes
    theme: sandstone
    toc: yes
    toc_depth: 3
    toc_float: yes
---

```{r, include=FALSE}
knitr::opts_chunk$set(tidy=TRUE, results='hold', fig.align='center')
```

```{r, echo=FALSE, include=FALSE}
library(lobstr)
library(pryr)
library(knitr)
library(kableExtra)
library(magrittr)

```

# Vectors
Vectors can be organized by their dimension (1d, 2d, nd) and whether they're all homogeneous or heterogeneous. This gives rise to the five types most often used in data analysis:

Dimension     | Homogeneous   | Heterogeneous
------------- | ------------- | -------------
1d            | Atomic vector | List
2d            | Matrix        | Data frame
nd            | Array         |

```{r, echo=FALSE}
d <- c("1d", "2d", "nd")
ho <- c("Atomic vector", "Matrix", "Array")
he <- c("List", "Data frame", "")
dt <- data.frame(Dimension = d, Homogeneous = ho, Heterogeneous = he, stringsAsFactors = FALSE)
kable(dt) %>%
  kable_styling(bootstrap_options = c("condensed", "hover"), full_width = FALSE, position = "left")
```

Note that R has no 0-dimensional, or scalar types. Individual numbers or strings are vectors of length one.

Vectors come in two flavours:

* Atomic vectors
* Lists

```{r, out.width="200px", echo=FALSE}
knitr::include_graphics("Images/summary.png")
```

They have three common properties:

* Type, `typeof()`, what it is.
* Length, `length()` how many elementd it contains.
* Attributes, `attributes()`, additional arbitrary metadata.

All elementd of an atomic vector must be the same type, whereas the elements of a list can have different types.

## Atomic vectors
There are 6 types of atomic vectors:

* Logical
* Integer
* Double
* Character
* Complex - used for complex arithmetic
* Raw - intended to hold raw bytes

```{r}
dbl_var <- c(1, 2.5, 4.5)
int_var <- c(1L, 6L, 10L)
log_var <- c(TRUE, FALSE, T, F)
chr_var <- c("these are","some strings")
```

```{r, out.width="200px", echo=FALSE}
knitr::include_graphics("Images/Atomic.png")
```

Atomic vectors are always flat, even if you nest with `c()`'s:

```{r}
c(1, c(2, c(3,4)))
# the same as
c(1, 2, 3, 4)
```

Missing values are specified with `NA`, which is a logical vector of length 1. `NA` will always be coerced to the correct type if used inside `c()`, or you can create `NA`s of the correct type with `NA_real_`, `NA_integer_` and `NA_character_`.

### Types and tests
Given a vector, you can determine its type with `typeof()`.

Use "is" functions with care. `is.character()`, `is.double()`, `is.integer()` and `is.logical()` are ok. The following are surprising:

* `is.vector()` tests for vectors with no attributes apart from names. Use `is.atomic() || is.list()` to test if an object is actually a vector.
* `is.atomic()` tests for atomic vectors or `NULL`.
* `is.numeric()` tests for the numerical-ness of a vector, not whether it's built on top of an integer or double.

```{r}
null_var <- NULL
is.atomic(null_var)
typeof(null_var)

int_var <- c(1L, 6L, 10L)
typeof(int_var)
```



