---
title: "S3"
output:
  html_document:
    number_sections: yes
    theme: sandstone
    toc: yes
    toc_depth: 3
    toc_float: yes
---

```{r, include=FALSE}
knitr::opts_chunk$set(tidy=TRUE, fig.align='center')
```

```{r, echo=FALSE, include=FALSE}
library(rlang)
library(pryr)
library(knitr)
library(kableExtra)
library(magrittr)
library(dplyr)
library(tidyverse)
library(lobstr)
library(memoise)
library(purrr)
```

# Introduction
S3 is R’s first and simplest OO system. S3 is informal and ad hoc, but it has a certain elegance in its minimalism: you can’t take away any part of it and still have a useful OO system. Because of these reasons, S3 should be your default choice for OO programming: you should use it unless you have a compelling reason otherwise. S3 is the only OO system used in the base and stats packages, and it’s the most commonly used system in CRAN packages.

S3 is a very flexible system: it allows you to do a lot of things that are quite ill-advised. If you’re coming from a strict environment like Java, this will seem pretty frightening (and it is!) but it does give R programmers a tremendous amount of freedom. While it’s very difficult to prevent someone from doing something you don’t want them to do, your users will never be held back because there is something you haven’t implemented yet. Since S3 has few built-in constraints, the key to its successful use is applying the constraints yourself. This chapter will teach you the conventions you should (almost) always adhere to in order to use S3 safely.

# Basics
An S3 object is built on top of a base type with the “class” attribute set. The base type is typically a vector, although we will see later that it’s possible to use other types of classes. For example, take the factor. It is built on top of an integer vector, and the value of the class attribute is “factor”. It stores information about the “levels” in another attribute.

```{r}
f <- factor("a")

typeof(f)
attributes(f)
```

An S3 object behaves differently from its underlying base type because of **generic functions**, or **generics** for short. A generic executes different code depending on the class of one of its arguments, almost always the first. You can see this difference with the most important generic function: `print()`.

```{r}
print(f)
print(unclass(f))
```

`unclass()` strips the class attribute from its input, so it is a useful tool for seeing what special behaviour an S3 class adds.

`str()` shows the internal structure of S3 objects. Be careful when using `str()`: some S3 classes provide a custom `str()` method which can hide the underlying details. For example, take the `POSIXlt` class, which is one of the two classes used to represent date-time data:

```{r}
time <- strptime("2017-01-01", "%Y-%m-%d")
str(time)
str(unclass(time))
```

A **generic** and its **methods** are functions that operate on classes. The role of a generic is to find the right method for the arguments that it is provided, the process of **method dispatch**. A method is a function that implements the generic behaviour for a specific class. In other words the job of the generic is to find the right method; the job of the method is to do the work.

S3 methods are functions with a special naming scheme, `generic.class()`. For example, the Date method for the `mean()` generic is called `mean.Date()`, and the factor method for `print()` is called `print.factor()`. This is the reason that most modern style guides discourage the use of `.` in function names: it makes them look like S3 methods. For example, is `t.test()` the t method for `test` objects?

You can find some S3 methods (those in the base package and those that you’ve created) by typing their names. However, this will not work with most packages because S3 methods are not exported: they live only inside the package, and are not available from the global environment. Instead, you can use `getS3method()`, which will work regardless of where the method lives:

```{r}
# Only works because the method is in the base package
mean.Date

# Always works
getS3method("mean", "Date")
```

## Exercises
1. The most important S3 objects in base R are factors, data frames, and date/times (Dates, POSIXct, POSIXlt). You’ve already seen the attributes and base type that factors are built on. What base types and attributes are the others built on?  
**A**: Data frames are build up on (named) lists. Together with the `row.names` attribute and after setting the class to “data.frame”, we get a classical data frame.
    ```{r}
    df <- data.frame()
    attributes(df)
    
    df_build <- structure(list(1:2, 3:4),
                          names = c("a", "b"),
                          row.names = 1:2, 
                          class = "data.frame")
    
    df_classic <- data.frame(a = 1:2, b = 3:4)
    
    identical(df_build, df_classic)
    ```
Date is just a double with the class attribute set to “Date”

    ```{r}
    d <- as.Date("1970-01-01")
    attributes(d)
    
    date_build <- structure(0, class = "Date")
    date_classic <- as.Date("1970-01-01")
    identical(date_build, date_classic)
    ```
POSIXct is a class for date/times that inherits from POSIXt and is built on doubles as well. The only attribute is tz (for timezone)
    ```{r}
    POSIXct_build <- structure(1, class = c("POSIXct", "POSIXt"), tzone = "CET")
    POSIXct_classic <- .POSIXct(1, tz = "CET") # note that tz's default is NULL
    identical(POSIXct_build, POSIXct_classic)
    ```
POSIXlt is another date/time class that inherits from POSIXt. It is built on top of a named list and a tzone attribute. Differences between POSIXct and POSIXlt are described in `?DateTimeClasses`.
    ```{r}
    POSIXlt_build <- structure(list(sec = 30,
                                    min = 30L,
                                    hour = 14L,
                                    mday = 1L,
                                    mon = 0L,
                                    year = 70L,
                                    wday = 4L,
                                    yday = 0L,
                                    isdst = 0L,
                                    zone = "CET",
                                    gmtoff = 3600L),
                               tzone = c("", "CET", "CEST"),
                               class = c("POSIXlt", "POSIXt"))
    POSIXlt_classic <- as.POSIXlt(.POSIXct(13.5 * 3600 + 30))
    identical(POSIXlt_build, POSIXlt_classic)
    ```

2. Describe the difference in behaviour in these two calls.
    ```{r}
    set.seed(1014)
    some_days <- as.Date("2017-01-31") + sample(10, 5)
    
    mean(some_days)
    mean(unclass(some_days))
    ```
**A**: Since `mean()` is a generic and some_days is an object of class Date, the first call results in `mean.Date(some_days)`. In the second call `unclass()` removes the class attribute from some_days, which means that unclass(some_days)` is not an OO object and the call results in `mean.default(unclass(some_days))`, which calculates the mean of the underlying double. Note:
    ```{r}
    mean.Date
    ```





