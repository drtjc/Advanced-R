---
title: "Evaluation"
output:
  html_document:
    number_sections: yes
    theme: sandstone
    toc: yes
    toc_depth: 3
    toc_float: yes
---

```{r, include=FALSE}
knitr::opts_chunk$set(tidy=TRUE, fig.align='center')
```

```{r, echo=FALSE, include=FALSE}
library(rlang)
library(pryr)
library(knitr)
library(kableExtra)
library(magrittr)
library(dplyr)
library(tidyverse)
library(lobstr)
library(memoise)
library(purrr)
```

# Evaluation
## Introduction
The user-facing opposite of quotation is unquotation: it gives the user the ability to selectively evaluate parts of an otherwise quoted argument. The developer-facing complement of quotation is evaluation: this gives the developer the ability to evaluate quoted expressions in custom environments to achieve specific goals.

This chapter begins with a discussion of evaluation in its purest form with `rlang::eval_bare()` which evaluates an expression in given environment. We’ll then see how these ideas are used to implement a handful of base R functions, and then learn about the similar `base::eval()`.

The meat of the chapter focusses on extensions needed to implement evaluation robustly. There are two big new ideas:

* We need a new data structure that captures both the expression and the environment associated with each function argument. We call this data structure a quosure.

* `base::eval()` supports evaluating an expression in the context of a data frame and an environment. We formalise this idea by calling it data mask and to resolve the ambiguity it creates, introduce the idea of data pronouns.

Together, quasiquotation, quosures, data masks, and pronouns form what we call tidy evaluation, or tidy eval for short. Tidy eval provides a principled approach to NSE that makes it possible to use such functions both interactively and embedded with other functions. We’ll finish off the chapter showing the basic pattern you use to wrap quasiquoting functions, and how you can adapt that pattern to base R NSE functions.

## Evaluation basics
n the previous chapter, we briefly mentioned eval(). Here, however, we’re going to start with `rlang::eval_bare()` which is the purest evocation of the idea of evaluation. The first argument, `expr` is an expression to evaluate. This will usually be either a symbol or expression:

```{r}
x <- 10
eval_bare(expr(x))

y <- 2
eval_bare(expr(x + y))
```

Everything else yields itself when evaluated:

```{r}
eval_bare(10)
```

The second argument, `env`, gives the environment in which the expression should be evaluated, i.e. where should the values of `x`, `y`, and `+` be looked for? By default, this is the current environment, i.e. the calling environment of `eval_bare()`, but you can override it if you want:

```{r}
eval_bare(expr(x + y), env(x = 1000))
```

Because R looks up functions in the same way as variables, we can also override the meaning of functions. This is a very useful technique if you want to translate R code into something else, as you’ll learn about in the next chapter.

```{r}
eval_bare(
  expr(x + y), 
  env(`+` = function(x, y) paste0(x, " + ", y))
  )
```

Note that the first argument to `eval_bare()` (and to `base::eval()`) is evaluated, not quoted. This can lead to confusing results if you forget to quote the input:

```{r}
eval_bare(x + y)
eval_bare(x + y, env(x = 1000))
```

### Application: `local()`
Sometimes you want to perform a chunk of calculation that creates a bunch of intermediate variables. The intermediate variables have no long-term use and could be quite large, so you’d rather not keep them around. One approach is to clean up after yourself using `rm()`; another approach is to wrap the code in a function, and just call it once. A more elegant approach is to use `local()`:

```{r, error=TRUE}
# Clean up variables created earlier
rm(x, y)

foo <- local({
  x <- 10
  y <- 200
  x + y
})

foo
x
y
```

The essence of `local()` is quite simple. We capture the input expression, and create a new environment in which to evaluate it. This inherits from the caller environment so it can access the current lexical scope, but any intermediate variables will be GC’d once the function has returned.

```{r, error=TRUE}
local2 <- function(expr) {
  env <- child_env(caller_env())
  eval_bare(enexpr(expr), env)
}

foo <- local2({
  x <- 10
  y <- 200
  x + y
})

foo
x
y
```

### Application: `source()`
We can create a simple version of `source()` by combining `parse_expr()` and `eval_bare()`. We read in the file from disk, use `parse_expr()` to parse the string into a list of expressions, and then use `eval_bare()` to evaluate each component in turn. This version evaluates the code in the caller environment, and invisibly returns the result of the last expression in the file like `source()`.

```{r}
source2 <- function(path, env = caller_env()) {
  file <- paste(readLines(path, warn = FALSE), collapse = "\n")
  exprs <- parse_exprs(file)

  res <- NULL
  for (i in seq_along(exprs)) {
    res <- eval_bare(exprs[[i]], env)
  }
  
  invisible(res)
}
```

The real `source()` is considerably more complicated because it can echo input and output, and has many other settings that control its behaviour.

### Base R
The base function equivalent to `eval_bare()` is the two-argument form of `eval()`: `eval(expr, envir)`:

```{r}
eval(expr(x + y), env(x = 1000, y = 1))
```

The final argument, `enclos` provides support for data masks, which you’ll learn about in tidy evaluation.

`eval()` is paired with two helper functions:

* `evalq(x, env)` quotes its first argument, and is hence a shortcut for `eval(quote(x), env)`.

* `eval.parent(expr, n)` is shortcut for `eval(expr, env = parent.frame(n))`.

### Exercises
1. Carefully read the documentation for `source()`. What environment does it use by default? What if you supply `local = TRUE`? How do you provide a custom argument?  
**A**: By default, `local = FALSE` hence the global environment is used. If `local = TRUE` then the calling environment is used. If `local` is an environment, then that is used.
    ```{r, eval=FALSE}
    # code snippet from source()
    
    envir <- if (isTRUE(local)) 
        parent.frame()
    else if (isFALSE(local)) 
        .GlobalEnv
    else if (is.environment(local)) 
        local
    else stop("'local' must be TRUE, FALSE or an environment")
    ```
For example:
```{r}
tmp <- tempfile()
writeLines("print(x)", tmp)  # create a temporary R-script

x <- 2

source_local <- function(file, local){
  local({
    x <- 3
    source(file, local = local)
  })      
}

env2 <- rlang::env(x = 4)

source_local(tmp, FALSE)
source_local(tmp, TRUE)
source_local(tmp, env2)
```

2. Predict the results of the following lines of code:
    ```{r}
    eval(quote(eval(quote(eval(quote(2 + 2))))))
    eval(eval(quote(eval(quote(eval(quote(2 + 2)))))))
    quote(eval(quote(eval(quote(eval(quote(2 + 2)))))))
    ```
**A**: `4`, `4`, `eval(quote(eval(quote(eval(quote(2 + 2))))))`



6. We can make `base::local()` slightly easier to understand by spreading out over multiple lines:
    ```{r, eval=FALSE}
    local3 <- function(expr, envir = new.env()) {
      call <- substitute(eval(quote(expr), envir))
      eval(call, envir = parent.frame())
    }
    ```

Explain how `local()` works in words. (Hint: you might want to `print(call`) to help understand what `substitute()` is doing, and read the documentation to remind yourself what environment `new.env()` will inherit from.)
**A**:
```{r, error=TRUE}
local3 <- function(expr, envir = new.env()) {
  call <- substitute(eval(quote(expr), envir))
  print(call)
  eval(call, envir = parent.frame())
}

rm(x, y)
Z < 50
foo <- local3({
  x <- 10
  y <- 200
  x + y + z
})

# the print of call gives
# eval(quote({
#     x <- 10
#     y <- 200
#     x + y + z
# }), new.env())
```
**A**: the variable `call` is an expression of the form `eval(quote(expr), envir)`, but where `expr` and `envir` have now been substituted for the aruments passed to `local3`. which is evaluated in the calling environment (`parent.frame()`).  The evaluation of call
