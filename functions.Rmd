---
title: "Functions"
output:
  html_document:
    number_sections: yes
    theme: sandstone
    toc: yes
    toc_depth: 3
    toc_float: yes
---

```{r, include=FALSE}
knitr::opts_chunk$set(tidy=TRUE, fig.align='center')
```

```{r, echo=FALSE, include=FALSE}
library(lobstr)
library(pryr)
library(knitr)
library(kableExtra)
library(magrittr)
library(dplyr)
library(tidyverse)
```

# Functions
The most important thing to understand about R is that functions are objects in their own right, a language property often called “first-class functions”. You can work with them exactly the same way you work with any other type of object. 

## Function components
All R functions have three parts:

* The `formals()`, the list of arguments that control how you call the function.

* The `body()`, the code inside the function.

* The `environment()`, which determines how the function finds values associated with names.

When you print a function in R, it shows you these three important components. If the environment isn’t displayed, it means that the function was created in the global environment.

```{r}
f <- function(x) {
  # A comment
  x ^ 2
}
f
formals(f)
body(f)
environment(f)
```

Like all objects in R, functions can also possess any number of additional `attributes()`. One attribute used by base R is “srcref”, short for source reference, which points to the source code used to create the function. Unlike `body()`, this contains code comments and other formatting. You can also add attributes to a function. For example, you can set the `class()` and add a custom `print()` method.

```{r}
attributes(f)
```

The assignment forms of `body()`, `formals()`, and `environment()` can also be used to modify functions.

```{r}
formals(f) <- alist(x = , y = 5 * 2) # alist allows tags without values. Values are not evaluated
f
body(f) <- expression(x ^ 3 + y)
f
f(2)
```

## Primitive functions
There is one exception to the rule that functions have three components. Primitive functions, like `sum()`, call C code directly with `.Primitive()` and contain no R code. Therefore their `formals()`, `body()`, and `environment()` are all `NULL`:

```{r}
sum
formals(sum)
body(sum)
environment(sum)
```

Primitive functions are only found in the base package. The chief advantage of primitive functions is that they can truly modify objects in place

## Exercises
1. What function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function?  
**A**: 
    ```{r, results='hold'}  
    f <- function(x) x ^ 2
    is.function(f)
    is.function(sum)
    is.primitive(f)
    is.primitive(sum)
    ```

2. This code makes a list of all functions in the base package. Use it to answer the following questions:
    ```{r}
    objs <- mget(ls("package:base"), inherits = TRUE)
    funs <- Filter(is.function, objs)
    ```

    Which base function has the most arguments?
    ```{r}
    f_arg_length <- funs %>% map_int(~ length(formals(.)))
    f_arg_length[which.max(f_arg_length)]
    ```

    How many base functions have no arguments? What’s special about those functions?
    ```{r}
    # functions without arguments
    f_arg_length <- funs %>% map_int(~ length(formals(.)))
    f_arg_length[which.max(f_arg_length)]
    sum(f_arg_length == 0) 
    
    # all primitive functions return NULL for formals, but so do other functions with no arguments
    f_arg_NULL <- funs %>% map_lgl(~ is.null(formals(.)))
    sum(f_arg_NULL) 
    
    f_arg_0 <- funs %>% map_lgl(~ !is.null(formals(.)) && length(formals(.)) == 0)
    sum(f_arg_0) #0 - non-primitive functions with no arguments return NULL for a formal
    
    f_arg_primitve <- funs %>% map_lgl(~ is.primitive(.))
    sum(f_arg_primitve) # number of primitive functions
    
    f_arg_NULL_not_primitive <- funs %>% map_lgl(~ is.null(formals(.)) && !is.primitive(.))
    sum(f_arg_NULL_not_primitive) # number of non-primitive functions with no arguments
    
    # non-primitve functions with no arguments
    str(funs[which(f_arg_NULL_not_primitive)])
    ```

    How could you adapt the code to find all primitive functions?
    ```{r}
    objs <- mget(ls("package:base"), inherits = TRUE)
    funs <- Filter(is.primitive, objs)
    length(funs)
    ```

3. What are the three important components of a function?  
**A**: The `formals()`, `body()` and `environment()`. 

4. When does printing a function not show what environment it was created in?  
**A**: When the function was created in the global environment.


## Lexical scoping
In Names and values, we discussed assignment, the act of binding a name to a value. Scoping works in the opposite direction: how do you find the value associated with a given name in a given context?

For example, what will the following code return, 10 or 20?
```{r}
x <- 10
f <- function() {
  x <- 20
  x
}

f()
```

There are four primary rules that define R’s lexical scoping:

* Name masking
* Functions vs. variables
* A fresh start
* Dynamic lookup

### Name masking
The following example illustrates the most basic principle of lexical scoping: names in defined inside a function override names defined outside of it.
```{r}
x <- 10
y <- 20
f <- function() {
  x <- 1
  y <- 2
  c(x, y)
}
f()
```

If a name isn’t defined inside a function, R will look one level up.
```{r}
x <- 2
g <- function() {
  y <- 1
  c(x, y)
}
g()
```

The same rules apply if a function is defined inside another function: look inside the current function, then where that function was defined, and so on, all the way up to the global environment, and then on to other loaded packages.
```{r}
x <- 1
h <- function() {
  y <- 2
  i <- function() {
    z <- 3
    c(x, y, z)
  }
  i()
}
h()
```

The same rules apply to closures, functions created by other functions. The following function, `j()`, returns a function.
```{r}
j <- function(x) {
  y <- 2
  function() {
    c(x, y)
  }
}
k <- j(1)
k()
```

This seems a little magical: how does R know what the value of `y `is after `j()` has returned? It works because `k` preserves the environment in which it was defined and because the environment includes the value of `y`.

### Functions vs. variables
The same principles apply regardless of the type of associated value — functions are found in the same way as variables:

```{r}
l <- function(x) x + 1
m <- function() {
  l <- function(x) x * 2
  l(10)
}
m()
```

There is one small tweak to the rule for functions. If you are using a name in a context where it’s obvious that you want a function (e.g., f(3)), R will ignore objects that are not functions while it is searching. In the following example n takes on a different value depending on whether R is looking for a function or a variable.

```{r}
n <- function(x) x / 2
o <- function() {
  n <- 10
  n(n)
}
o()
```

However, using the same name for functions and other objects will make for confusing code, and is best avoided.

### A fresh start
What happens to the values in between invocations of a function?

```{r}
j <- function() {
  if (!exists("a")) {
    a <- 1
  } else {
    a <- a + 1
  }
  a
}

j()
j()
```

`j()` returns the same value, 1, every time it is called. This is because every time a function is called, a new environment is created to host its execution. A function has no way to tell what happened the last time it was run; each invocation is completely independent. (We’ll see some ways to get around this in mutable state.)

## Dynamic lookup
Lexical scoping determines where to look for values, not when to look for them. R looks for values when the function is run, not when it’s created. This means that the output of a function can be different depending on objects outside its environment:

```{r}
f <- function() x
x <- 15
f()

x <- 20
f()
```

This behaviour can be quite annoying. If you make a spelling mistake in your code, you won’t get an error when you create the function, and you might not even get one when you run the function, depending on what variables are defined in the global environment.

One way to detect this problem is to use `codetools::findGlobals()`. This function lists all the external dependencies (unbound symbols) within a function:

```{r}
f <- function() x + 1
codetools::findGlobals(f)
```

Another way to try and solve the problem would be to manually change the environment of the function to the `emptyenv()`, an environment which contains nothing:

```{r, error=TRUE}
environment(f) <- emptyenv()
f()
```

Both of these approaches reveal why this undesirable behaviour exists: R relies on lexical scoping to find everything, even the `+` operator.

## Exercises
1. What does the following code return? Why? What does each of the three `c`s mean?

```{r}
c <- 10
c(c = c)
```



# DO RECURSIVE SUBSETTING
